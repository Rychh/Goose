module SkelGrammar where

-- Haskell module generated by the BNF converter
import Control.Monad.Reader
import Control.Monad.State
import Control.Monad.Except
import Control.Monad.IO.Class
import Data.Map

-- import qualified Data.Map as Map
import qualified Data.Set as Set
import AbsGrammar
import ErrM

type Variable = Ident
type FName = Ident
type Location = Integer
data Value = Int Int 
  | Bool Bool 
-- | Array Int (Map.Map Int Location)
-- | Fun Fun
 deriving (Show, Eq, Ord)
newtype Fun = Fun ([Value] -> Interpreter Value)

type Store = Map Location Value
type Env = (Map Variable Location,  Map FName Fun)
-- type Map = Map.Map -- ??

-- type Context = (Env, IO Maybe Variable)

type Result = ExceptT String IO

type Interpreter a = StateT Store (ReaderT Env Result) a

-- type FunctionType = Ident -> [Variable] -> [Expr] -> Interpreter Context

-- failure :: Show a => a -> Result
-- failure x = Bad $ "Undefined case: " ++ show x

-- transIdent :: Ident -> Interpreter 
-- transIdent x = case x of
--   Ident string -> failure x

interpret :: Program -> (Result ())
interpret p = do
  runReaderT (execStateT (transProgram p) empty) (empty, empty)
  return ()


transProgram :: Program -> Interpreter ()
transProgram (Program ds) = do
  env <- transTopDefs ds
  (Fun main) <- local (const env) $ getFun (Ident "main")
  local (const env) $ main []
  return ()


transTopDefs :: [TopDef] -> Interpreter Env
transTopDefs [] = ask
transTopDefs (d:ds) = do
  env1 <- transTopDef d
  env2 <- local (const env1) $ transTopDefs ds
  return env2

transTopDef :: TopDef -> Interpreter Env
transTopDef (FnDef ident args block) = do
  env <- ask
  -- let fun values = do
  --   env' <- local (const env) $ transArguments values arguments -- params
  return env

getFun :: FName -> Interpreter Fun
getFun f = do
  env <- ask
  return $ snd env ! f 

next :: Interpreter Location
next = do
  store <- get
  let loc = if size store /= 0 then (fst $ findMax store) + 1 else 1
  put store
  return loc


transArguments :: [Arg] -> [Value]-> Interpreter Env
transArguments [] [] = ask
transArguments (var:vars) (val:vals) =
  local (transArgument var val) $ transArguments
  -- loc <- alloc
  -- modify (\store -> insert loc val store)
  -- env' <- local (transArgument var val) $ transArguments



transArgument :: Arg -> Value-> Interpreter Env
transArgument var val = case var of
  Arg ident -> do
    loc <- next
    modify (\store -> insert loc val store)
    (eVar, eFun) <- ask
    eVar' <- insert ident loc eVar
    return (eVar', eFun)
  CntsArg ident -> do
    lift $ putStrLn "TODO, nie zapomnij dodac constow"
    return $ transArgument (Arg ident)

-- transBlock :: Block -> Result
-- transBlock x = case x of
--   Block stmts -> failure x
-- transStmt :: Stmt -> Result
-- transStmt x = case x of
--   Empty -> failure x
--   BStmt block -> failure x
--   DeclCon ident expr -> failure x
--   DeclFun ident args block -> failure x
--   Ass ident expr -> failure x
--   TupleAss ident exprs -> failure x
--   TupleAss1 args exprs -> failure x
--   TupleAss2 args expr -> failure x
--   Incr ident -> failure x
--   Decr ident -> failure x
--   Ret expr -> failure x
--   RetTuple exprs -> failure x
--   VRet -> failure x
--   Cond expr stmt -> failure x
--   CondElse expr stmt1 stmt2 -> failure x
--   While expr stmt -> failure x
--   For ident expr1 expr2 stmt -> failure x
--   ForIn ident1 ident2 stmt -> failure x
--   Break -> failure x
--   Conti -> failure x
--   SExp expr -> failure x
--   PrInt expr -> failure x
--   PrStr expr -> failure x
--   Honk expr -> failure x
--   Error -> failure x
-- transExpr :: Expr -> Result
-- transExpr x = case x of
--   EVar ident -> failure x
--   ELitInt integer -> failure x
--   ELitTrue -> failure x
--   ELitFalse -> failure x
--   EApp ident exprs -> failure x
--   EString string -> failure x
--   EList exprs -> failure x
--   EList1 expr1 expr2 -> failure x
--   EAt ident expr -> failure x
--   Neg expr -> failure x
--   Not expr -> failure x
--   EMul expr1 mulop expr2 -> failure x
--   EAdd expr1 addop expr2 -> failure x
--   ERel expr1 relop expr2 -> failure x
--   EAnd expr1 expr2 -> failure x
--   EOr expr1 expr2 -> failure x
--   ELambda args block -> failure x
--   ELambdaS args block -> failure x
-- transAddOp :: AddOp -> Result
-- transAddOp x = case x of
--   Plus -> failure x
--   Minus -> failure x
-- transMulOp :: MulOp -> Result
-- transMulOp x = case x of
--   Times -> failure x
--   Div -> failure x
--   Mod -> failure x
-- transRelOp :: RelOp -> Result
-- transRelOp x = case x of
--   LTH -> failure x
--   LE -> failure x
--   GTH -> failure x
--   GE -> failure x
--   EQU -> failure x
--   NE -> failure x

