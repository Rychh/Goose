module SkelGrammar where

-- Haskell module generated by the BNF converter
import Control.Monad.Reader
import Control.Monad.State
import Control.Monad.Except
import Control.Monad.IO.Class
import Data.Map

-- import qualified Data.Map as Map
import qualified Data.Set as Set
import AbsGrammar
import ErrM

type Variable = Ident
type FName = Ident
type Location = Integer
data Value = Int Int 
  | Bool Bool 
-- | Array Int (Map.Map Int Location)
-- | Fun Fun
 deriving (Show, Eq, Ord)
newtype Fun = Fun ([Value] -> Interpreter Value)

type Store = Map Location Value
type EnvVar = Map Variable Location
type EnvFun = Map FName Fun

type Context = (EnvVar, EnvFun)

type Result = ExceptT String IO

type Interpreter a = StateT Store (ReaderT Context Result) a

-- type FunctionType = Ident -> [Variable] -> [Expr] -> Interpreter Context

failure :: Stmt -> Interpreter Context
failure x = do
  context <- ask
  lift $ lift $ lift $ putStrLn "Cos zapomniales zaimplementowac" -- todo xd czemu tyle liftów
  return $ context
-- transIdent :: Ident -> Interpreter 
-- transIdent x = case x of
--   Ident string -> failure x

interpret :: Program -> (Result ())
interpret p = do
  runReaderT (execStateT (transProgram p) empty) (empty, empty)
  return ()


transProgram :: Program -> Interpreter ()
transProgram (Program ds) = do
  context <- transTopDefs ds
  (Fun main) <- local (const context) $ getFun (Ident "main")
  local (const context) $ main []
  return ()


transTopDefs :: [TopDef] -> Interpreter Context
transTopDefs [] = ask
transTopDefs (d:ds) = do
  context <- transTopDef d
  newCont <- local (const context) $ transTopDefs ds
  return newCont

transTopDef :: TopDef -> Interpreter Context
transTopDef (FnDef funName args block) = do
  context <- ask
  let newFun = transTopDefHlp context funName args block 
  --   newCont2 <- local (const newCont1) $ transBlock block
    -- todo może jakieś rekurencja
  return $ setFun funName (Fun (newFun)) context

transTopDefHlp context funName args block  values = do
  newCont1 <- local (const context) $ transArguments args values-- params
  -- let newCont2 = setFun funName dupa newCont1 -- recursion
  -- local (const newCont2) $ transBlock block
  local (const newCont1) $ transBlock block
  return $ Int 0

getFun :: FName -> Interpreter Fun
getFun f = do
  context <- ask
  return $ snd context ! f 

setFun :: FName -> Fun -> Context -> Context
setFun name fun (envVar, envFun) = 
  let newEnvFun = insert name fun envFun
  in (envVar, newEnvFun)

next :: Interpreter Location
next = do
  store <- get
  let loc = if size store /= 0 then (fst $ findMax store) + 1 else 1
  put store
  return loc


transArguments :: [Arg] -> [Value]-> Interpreter Context
transArguments [] [] = ask
transArguments (var:vars) (val:vals) = do
  newCont1 <- transArgument var val
  newCont2 <- local (const newCont1) $ transArguments vars vals -- todo co robi to const?
  return newCont2
  -- loc <- alloc
  -- modify (\store -> insert loc val store)
  -- env' <- local (transArgument var val) $ transArguments



transArgument :: Arg -> Value-> Interpreter Context
transArgument var val = case var of
  Arg ident -> do
    loc <- next
    modify (\store -> insert loc val store)
    (envVar, envFun) <- ask
    let newEnvVar = insert ident loc envVar
    return (newEnvVar, envFun)
  CntsArg ident -> do
    lift $ lift $ lift $ putStrLn "TODO, nie zapomnij dodac constow" -- todo xd czemu tyle liftów
    newCont <- transArgument (Arg ident) val
    return newCont
 
transBlock :: Block -> Interpreter Context
transBlock (Block (stmt:stmts)) = do
  newCont1 <- transStmt stmt
  newCont2 <- local (const newCont1) (transBlock (Block stmts))
  return $ newCont2
-- transBlock (x:xs) = do
  -- return 0

   
transStmt :: Stmt -> Interpreter Context
transStmt x = case x of
  Empty -> failure x
  BStmt block -> failure x
  DeclCon ident expr -> failure x
  DeclFun ident args block -> failure x
  Ass ident expr -> failure x
  TupleAss ident exprs -> failure x
  TupleAss1 args exprs -> failure x
  TupleAss2 args expr -> failure x
  Incr ident -> failure x
  Decr ident -> failure x
  Ret expr -> failure x
  RetTuple exprs -> failure x
  VRet -> failure x
  Cond expr stmt -> failure x
  CondElse expr stmt1 stmt2 -> failure x
  While expr stmt -> failure x
  For ident expr1 expr2 stmt -> failure x
  ForIn ident1 ident2 stmt -> failure x
  Break -> failure x
  Conti -> failure x
  SExp expr -> failure x
  PrInt expr -> failure x
  PrStr expr -> failure x
  Honk expr -> failure x
  Error -> failure x
-- transExpr :: Expr -> Result
-- transExpr x = case x of
--   EVar ident -> failure x
--   ELitInt integer -> failure x
--   ELitTrue -> failure x
--   ELitFalse -> failure x
--   EApp ident exprs -> failure x
--   EString string -> failure x
--   EList exprs -> failure x
--   EList1 expr1 expr2 -> failure x
--   EAt ident expr -> failure x
--   Neg expr -> failure x
--   Not expr -> failure x
--   EMul expr1 mulop expr2 -> failure x
--   EAdd expr1 addop expr2 -> failure x
--   ERel expr1 relop expr2 -> failure x
--   EAnd expr1 expr2 -> failure x
--   EOr expr1 expr2 -> failure x
--   ELambda args block -> failure x
--   ELambdaS args block -> failure x
-- transAddOp :: AddOp -> Result
-- transAddOp x = case x of
--   Plus -> failure x
--   Minus -> failure x
-- transMulOp :: MulOp -> Result
-- transMulOp x = case x of
--   Times -> failure x
--   Div -> failure x
--   Mod -> failure x
-- transRelOp :: RelOp -> Result
-- transRelOp x = case x of
--   LTH -> failure x
--   LE -> failure x
--   GTH -> failure x
--   GE -> failure x
--   EQU -> failure x
--   NE -> failure x

